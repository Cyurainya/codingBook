# 小程序原理

## 双线程模型

### 双线程模型

小程序的渲染层和逻辑层分别由两个线程管理

- 渲染层：界面渲染相关的任务全都在**webView 线程**里执行。一个小程序存在多个界面，所以渲染层存在多个**webView 线程**。
- 逻辑层：采用 JSCore 线程运行 JS 脚本

### 原理

逻辑层和视图层通过系统层的`WeixinBridge`进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发事件通知逻辑层进行业务处理

用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。

## 原生组件

1. 组件被创建，包括组件属性会依次赋值。
2. 组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y 坐标）、宽高。
3. 组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。
4. 当位置或宽高发生变化时，组件会通知客户端做相应的调整。

### 流程

- 在渲染层，宿主环境会把 WXML 转化成对应的 JS 对象
- 在逻辑层发生数据变更的时候需要把宿主环境提供的 setState 方法把数据从逻辑层渲染到渲染层，再经过 diff，最后渲染

![小程序线程](https://www.wxapp-union.com/data/attachment/portal/202102/02/095306qpdff10fk39dp943.png)

### 为什么是双线程 多线程不行吗

让逻辑线程尽可能的 “轻” ，且 减少 逻辑线程与 UI 线程的通信 频率

### 好处

- 安全，指的是小程序的安全性，由于小程序提供给开发者更高的权限，小程序开发者拥有很多 OS 能力的 API，如果开发者利用这些 API 做些恶意的事情，那么对用户来说将是一场灾难（随便打开一个小程序，结果被黑客攻击了）。
- 稳定，指的是小程序的稳定性，某个小程序崩溃或者卡死，不应该影响宿主 APP 及其他小程序。手机上的小程序大部分只能同时打开一个小程序，所以读者可能无法理解什么是稳定性。PC 上可以同时打开很多个小程序，根据产品形态不同，有的产品形态的小程序可能在一个网页里面运行（多个小程序同时在同一个网页里运行），这时候某个小程序卡死（例如写一个死循环），它不应该导致其他的小程序和宿主环境也跟着卡死。
- 性能，要保证小程序的执行、渲染等效率要足够高效。
- 简单，小程序对于开发者要足够简单，最好无需学习直接上手。

### 多 UI 线程

每个小程序还需要有自己的多个`UI线程`。

## 组件系统

小程序是有自己的组件的，这些基本组件就是基于`Exparser`框架。Exparser 基于 WebComponents 的 ShadowDOM 模型，但是不依赖浏览器的原生支持，而且可以再纯 JS 环境中运行。

Exparser 内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，Exparser 会维护整个页面的节点树相关信息，包括节点的熟悉、事件绑定等，相当于一个简化的 Shadow DOM 实现

## 运行机制

1. 启动

热启动：假如用户已经打开某小程序，然后在一定时间内再次打开小程序，此时无需重新启动，只需将后台小程序切换到前台，这个过程就是热启动；
冷启动：用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即冷启动。

2. 销毁
   只有当小程序进入后台一定时间（不知道是多久），或者系统资源占用过高，才会被真正的销毁。

3. 更新机制
   开发者在后台发布新版本之后，无法立刻影响到所有现网用户，但最差情况下，也在发布之后 24 小时之内下发新版本信息到用户。

小程序每次冷启动时，都会检查是否有更新版本，如果返现有新版本，将会异步下载最新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。

## 路由

**前进**信号： 如果宿主环境是浏览器而承载 UI 页面的是 iframe，那么前进信号对应的行为是创建一个新的 iframe 盖在前一个页面的上面，并初始化新页面的生命周期。其他宿主环境和承载 UI 页面的容器原理与纯 Web 方案一致。

**后退**信号： 后退信号对应的行为是从页面栈的栈顶开始删除页面（承载 UI 界面的载体，如：iframe、WebView 等），官方提供给开发者的 API 可以通过参数设置回退几层，对应的行为是删除几个页面，最多删除 stack.length - 1 个（最多回退到首页）。

![小程序路由](https://camo.githubusercontent.com/c1532c237049e91f980ec72bb574a42123ff794aa436238e1a18b2ae631005ed/687474703a2f2f71696e69752e626b742e64656d6f732e736f2f2545352541342539412545372542412542462545372541382538422e706e67)

上图给出了当开发者调用 API 打开新页面时，路由的内部流程图。沙箱中发出信号到 Master，Master 接收信号后创建 iframe 推入页面栈，页面在创建的时候会同时把基础 JS 库带进去，页面创建后 JS 基础库会立刻执行初始化操作，初始化完毕后会发送一个信号通知 Master 页面已创建并初始化完毕，随后 Master 会发送信号到沙箱中。之所以这样设计流程是因为有两个目的：

1. 需要通知开发者页面已经创建成功。
2. 在沙箱中创建新页面的“根组件”，并正式开启新页面的生命周期与渲染的流程。

## 生命周期

- 小程序的入口是 Master，Master 既不属于 UI 层，也不属于沙箱，它是凌驾于所有的一个上帝视角。在宿主环境是浏览器的情况下，Master 为 index.js，它是整个程序的入口。
- 当沙箱环境初始化完毕后，它需要向 Master 发送一个信号，通知 Master 沙箱环境已经准备就绪。这时候 Master 会根据开发者设置的配置，创建小程序的第一个页面，也就是小程序的首页。

  > 配置信息中包含了小程序的路由信息，当然也包括哪个是小程序的首页以及对应的组件。

- 当第一个页面被推到页面栈后，该页面开始进行初始化工作，这个时候 UI 层可以拿到该页面的组件树以及每个组件对应的模板等信息，页面会从根组件开始初始化，在 UI 层组件初始化的过程中，UI 层的组件会发送信号到 Master，通知 Master 组件初始化完毕，Master 收到信号后需要发送一个信号到沙箱中，沙箱接收到信号后需要在沙箱环境中创建一个对应的组件用来执行开发者的 JS 逻辑.

![ui-login](https://camo.githubusercontent.com/dcde72f8f084df502fa9e9db511f27db1d552326db80df340fa84e4a8fd3b79d/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f544231437061327a344431674b306a535a46735858626c645658612d3536302d3233322e737667)

- 逻辑层组件被初始化的过程中，会触发两个生命周期函数：“beforeCreate”和“created”。
- 当逻辑层的组件初始化完毕后，会发送一个信号到渲染层的组件中，通知渲染层的组件逻辑层组件这边已经初始化完毕，并且会将组件的状态信息发送到渲染层组件，渲染层组件收到信号后，就可以拿着数据去做首次渲染操作

![ui/login](https://camo.githubusercontent.com/a341bc1f969c237f90666d6d5f5ba562b322e9a3420041bd1a4f528f41bb27a5/68747470733a2f2f696d672e616c6963646e2e636f6d2f7466732f544231716e4f367a344431674b306a535a4679585863694f5658612d3536302d3530362e737667)

- 当首次渲染完成后，渲染层组件会发送一个信号到逻辑层组件中，逻辑层组件收到信号后触发生命周期“onReady”通知开发者已经首次渲染完毕。

- 后面每当开发者调用 setData 修改数据时，逻辑层组件都会将最新的数据发送到渲染层对应的组件中，该组件会用最新的状态重新走一遍渲染流程。

- 如果这期间用户点击了组件中的某个绑定了事件的元素，那么 UI 层组件会发送信号到逻辑层中对应的组件，并将一些事件信息一同发过去，逻辑层组件收到信号后调用开发者绑定的函数并将事件信息通过参数传递给开发者，整个流程结束。

## 小程序和 H5 的区别

### 运行环境

- 简单来说，小程序是一种应用，运行的环境是微信（App）；H5 是一种技术，依附的外壳是是浏览器。
- H5 的运行环境是浏览器，包括 WebView，而微信小程序的运行环境并非完整的浏览器，因为小程序的开发过程中只用到一部分 H5 技术。
- 小程序的运行环境是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对性做了优化，配合自己定义的开发语言标准，提升了小程序的性能。
- 小程序中无法使用浏览器中常用的 window 对象和 document 对象，H5 可以随意使用。

### 开发成本

- H5 的开发，涉及开发工具（vscode、Atom 等）、前端框架（Angular、react 等）、模块管理工具（Webpack 、Browserify 等）、任务管理工具（Grunt、Gulp 等），还有 UI 库选择、接口调用工具（ajax、Fetch Api 等）、浏览器兼容性等等。尽管这些工具可定制化非常高，大部分开发者也有自己的配置模板，但对于项目中各种外部库的版本迭代、版本升级，这些成本加在一起那就是个不小数目了。
- 而开发一个微信小程序，由于微信团队提供了开发者工具，并且规范了开发标准，则简单得多。前端常见的 HTML、CSS 变成了微信自定义的 WXML、WXSS，官方文档中都有明确的使用介绍，开发者按照说明专注写程序就可以了。需要调用后端接口时，调用发起请求 API；需要上传下载时，调用上传下载 API；需要数据缓存时，调用本地存储 API；引入地图、使用罗盘、调用支付、调用扫码等等功能都可以直接使用；UI 库方面，框架带有自家 weui 库加成。并且在使用这些 API 时，不用考虑浏览器兼容性，不用担心出现 BUG，显而易见微信小程序的开发成本相对低很多。

### 系统权限

- 微信小程序相对于 H5 能获得更多的系统权限，比如：网络通信状态、数据缓存能力等，这些系统级权限都可以和微信小程序无缝衔接。
- 而这一点恰巧是 H5 被诟病的地方，这也是 H5 的大多应用场景被定位在业务逻辑简单、功能单一的原因。

### 运行流畅度

这条无论对于用户还是开发者来说，都是最直观的感受。长久以来，当 HTML5 应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立，尽管同样用 HTML +CSS + JS 去开发，但配合微信的解析器最终渲染出来的是原生组件的效果，自然体验上将会更进一步。

## 小程序优缺点

优点：

1. 开发成本低，不需要做太多的兼容处理。微信本身就提供了很多借口功能，后期可能会支持更多。
2. 更新快，不需要发布版本。
3. 依托于微信，可做多种形式的推广。
4. 随用随点，用完即走，无需下载。
5. 可提前发布预热版或做 AB 测试，无需发布版本。
6. 其他

缺点：

1. 安全问题，部分安全性比较高的最好还是要做 App。（互金）
2. 性能问题。对性能要求比较高的（大型游戏）不适合。
3. 不能灵活地操作 DOM，无法实现较为复杂的效果
4. 页面大小、打开页面数量受到限制
5. 再 jsCore 中 JS 体积比较大的情况下，其初始化时间会产生影响
6. 传输数据中，序列化和范序列化耗时需要考虑

## 参考文章:

1. [小程序架构](https://www.wxapp-union.com/article-6869-1.html)
2. [小程序底层思考 1](https://github.com/berwin/Blog/issues/43)
3. [小程序底层思考 2](https://github.com/berwin/Blog/issues/49)
4. [小程序和 h5 的区别](https://www.zhihu.com/question/308606560/answer/573696321)
5. [解剖小程序的 setData](https://godbasin.github.io/2018/10/05/wxapp-set-data/)
